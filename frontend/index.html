<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Posts Viewer</title>
    <link rel="stylesheet" href="/style.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1><span>üì±</span>Telegram Posts Viewer</h1>
            <p id="channelInfo">Loading channel info...</p>
        </div>
        
        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="totalPosts">0</div>
                <div class="stat-label">Total Posts</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="currentCategory">All</div>
                <div class="stat-label">Current Filter</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="displayedPosts">0</div>
                <div class="stat-label">Displayed</div>
            </div>
        </div>
        
        <div class="controls">
            <div class="filter-row">
                <select id="categoryFilter">
                    <option value="">All Categories</option>
                    <!-- Categories will be loaded dynamically -->
                </select>
                <button id="loadPostsBtn">
                    <span class="btn-text">üì• Load Posts</span>
                    <span class="spinner" style="display:none;">‚è≥</span>
                </button>
            </div>
            
            <div class="filter-row">
                <select id="mediaTypeFilter">
                    <option value="">All Media Types</option>
                    <option value="text">Text</option>
                    <option value="photo">Photo</option>
                    <option value="video">Video</option>
                    <option value="document">Document</option>
                    <option value="audio">Audio</option>
                </select>
                <select id="sortBy">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                </select>
            </div>
        </div>
        
        <div class="posts-container" id="postsContainer">
            <div class="no-posts" id="noPostsMessage">
                <div style="font-size:3rem;margin-bottom:10px;">üì≠</div>
                <h3>No posts loaded</h3>
                <p>Select filters and click "Load Posts" to begin</p>
            </div>
        </div>
        
        <div class="pagination" id="pagination" style="display:none;">
            <button class="page-btn" id="prevPageBtn" disabled>‚Üê Previous</button>
            <div class="page-info" id="pageInfo">Page 1</div>
            <button class="page-btn" id="nextPageBtn">Next ‚Üí</button>
        </div>
    </div>
    
    <div class="api-status" id="apiStatus">
        <span class="status-dot"></span>
        <span class="status-text">Connecting to API...</span>
    </div>

    <script>
        // Use relative path for API calls (same domain)
        const API_BASE_URL = '/api';
        let currentCategory = '';
        let currentMediaType = '';
        let currentSort = 'newest';
        let currentPage = 1;
        let postsPerPage = 10;
        let totalPosts = 0;
        let allPosts = [];
        
        // DOM Elements
        const postsContainer = document.getElementById('postsContainer');
        const noPostsMessage = document.getElementById('noPostsMessage');
        const categoryFilter = document.getElementById('categoryFilter');
        const mediaTypeFilter = document.getElementById('mediaTypeFilter');
        const sortBy = document.getElementById('sortBy');
        const loadPostsBtn = document.getElementById('loadPostsBtn');
        const totalPostsElement = document.getElementById('totalPosts');
        const currentCategoryElement = document.getElementById('currentCategory');
        const displayedPostsElement = document.getElementById('displayedPosts');
        const apiStatus = document.getElementById('apiStatus');
        const statusDot = apiStatus.querySelector('.status-dot');
        const statusText = apiStatus.querySelector('.status-text');
        const pagination = document.getElementById('pagination');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const channelInfo = document.getElementById('channelInfo');
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing Telegram Mini App...');
            
            // Check API health
            await checkApiHealth();
            
            // Load channel info
            await loadChannelInfo();
            
            // Load initial data
            await loadStats();
            await loadCategories();
            
            // Setup event listeners
            loadPostsBtn.addEventListener('click', loadPosts);
            
            categoryFilter.addEventListener('change', (e) => {
                currentCategory = e.target.value;
                currentCategoryElement.textContent = currentCategory || 'All';
                currentPage = 1;
            });
            
            mediaTypeFilter.addEventListener('change', (e) => {
                currentMediaType = e.target.value;
                currentPage = 1;
            });
            
            sortBy.addEventListener('change', (e) => {
                currentSort = e.target.value;
                currentPage = 1;
                renderPosts();
            });
            
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderPosts();
                }
            });
            
            nextPageBtn.addEventListener('click', () => {
                const totalPages = Math.ceil(allPosts.length / postsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderPosts();
                }
            });
            
            // Auto-load posts after 1 second
            setTimeout(() => {
                if (allPosts.length === 0) {
                    loadPosts();
                }
            }, 1000);
            
            // Initialize Telegram Web App if available
            initTelegramWebApp();
        });
        
        // Telegram Web App Initialization
        function initTelegramWebApp() {
            if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp) {
                const tg = window.Telegram.WebApp;
                
                // Expand to full screen
                tg.expand();
                
                // Set theme colors
                document.documentElement.style.setProperty('--primary', tg.themeParams.button_color || '#0088cc');
                document.documentElement.style.setProperty('--primary-dark', tg.themeParams.button_color || '#006699');
                document.documentElement.style.setProperty('--bg-color', tg.themeParams.bg_color || '#ffffff');
                document.documentElement.style.setProperty('--text-color', tg.themeParams.text_color || '#000000');
                
                // Update user info if available
                if (tg.initDataUnsafe.user) {
                    const user = tg.initDataUnsafe.user;
                    channelInfo.innerHTML = `Welcome, <strong>${user.first_name}</strong>! Viewing posts from channel`;
                    
                    // Add user info to API calls if needed
                    window.userId = user.id;
                }
                
                // Setup back button
                tg.BackButton.show();
                tg.BackButton.onClick(() => {
                    window.history.back();
                });
                
                console.log('Telegram Web App initialized successfully');
            }
        }
        
        // API Health Check
        async function checkApiHealth() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                const data = await response.json();
                
                if (data.status === 'healthy') {
                    statusDot.classList.add('connected');
                    statusText.textContent = 'API Connected';
                    apiStatus.style.backgroundColor = '#e8f5e9';
                    return true;
                } else {
                    statusText.textContent = 'API Issues';
                    apiStatus.style.backgroundColor = '#ffebee';
                    return false;
                }
            } catch (error) {
                console.error('API health check failed:', error);
                statusText.textContent = 'API Unreachable';
                apiStatus.style.backgroundColor = '#ffebee';
                return false;
            }
        }
        
        // Load channel information
        async function loadChannelInfo() {
            try {
                const response = await fetch(`${API_BASE_URL}/telegram-info`);
                const data = await response.json();
                
                if (data.success) {
                    const info = data.data;
                    channelInfo.textContent = `Viewing posts from ${info.channel_username}`;
                    
                    // Update page title
                    document.title = `${info.channel_username} - Posts Viewer`;
                }
            } catch (error) {
                console.error('Failed to load channel info:', error);
            }
        }
        
        // Load statistics
        async function loadStats() {
            try {
                const response = await fetch(`${API_BASE_URL}/stats`);
                const data = await response.json();
                
                if (data.success) {
                    totalPosts = data.data.total_posts || 0;
                    totalPostsElement.textContent = totalPosts.toLocaleString();
                    
                    // Update media type filter with actual types
                    updateMediaFilter(data.data.media_types);
                }
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        }
        
        // Update media type filter based on available media types
        function updateMediaFilter(mediaTypes) {
            // Clear existing options except first
            while (mediaTypeFilter.options.length > 1) {
                mediaTypeFilter.remove(1);
            }
            
            // Add media types that exist in data
            Object.keys(mediaTypes || {}).forEach(type => {
                if (type && type !== 'null') {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (${mediaTypes[type]})`;
                    mediaTypeFilter.appendChild(option);
                }
            });
        }
        
        // Load categories
        async function loadCategories() {
            try {
                const response = await fetch(`${API_BASE_URL}/categories`);
                const data = await response.json();
                
                if (data.success) {
                    // Clear existing options except first
                    while (categoryFilter.options.length > 1) {
                        categoryFilter.remove(1);
                    }
                    
                    // Add categories
                    data.data.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category.name;
                        option.textContent = `${category.name} (${category.count})`;
                        categoryFilter.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to load categories:', error);
            }
        }
        
        // Load posts
        async function loadPosts() {
            try {
                // Show loading state
                loadPostsBtn.disabled = true;
                loadPostsBtn.querySelector('.btn-text').textContent = 'Loading...';
                loadPostsBtn.querySelector('.spinner').style.display = 'inline-block';
                
                // Build API URL with parameters
                const params = new URLSearchParams();
                if (currentCategory) params.append('category', currentCategory);
                params.append('limit', 1000); // Get all posts for client-side filtering
                
                const url = `${API_BASE_URL}/posts?${params.toString()}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    allPosts = data.data || [];
                    displayedPostsElement.textContent = allPosts.length;
                    
                    // Process and render posts
                    processAndRenderPosts();
                    
                    // Show/hide elements based on data
                    if (allPosts.length > 0) {
                        noPostsMessage.style.display = 'none';
                        pagination.style.display = 'flex';
                    } else {
                        noPostsMessage.style.display = 'block';
                        pagination.style.display = 'none';
                    }
                } else {
                    showError('Failed to load posts: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error loading posts:', error);
                showError('Failed to connect to server. Please check your connection.');
            } finally {
                // Reset button state
                loadPostsBtn.disabled = false;
                loadPostsBtn.querySelector('.btn-text').textContent = 'üì• Load Posts';
                loadPostsBtn.querySelector('.spinner').style.display = 'none';
            }
        }
        
        // Process and render posts
        function processAndRenderPosts() {
            let filteredPosts = [...allPosts];
            
            // Apply media type filter
            if (currentMediaType) {
                filteredPosts = filteredPosts.filter(post => 
                    post.media_type === currentMediaType
                );
            }
            
            // Apply sorting
            filteredPosts.sort((a, b) => {
                const dateA = new Date(a.timestamp || a.created_at);
                const dateB = new Date(b.timestamp || b.created_at);
                return currentSort === 'newest' ? dateB - dateA : dateA - dateB;
            });
            
            allPosts = filteredPosts;
            renderPosts();
        }
        
        // Render posts to the page
        function renderPosts() {
            // Clear container
            postsContainer.innerHTML = '';
            
            if (allPosts.length === 0) {
                noPostsMessage.style.display = 'block';
                pagination.style.display = 'none';
                displayedPostsElement.textContent = '0';
                return;
            }
            
            // Calculate pagination
            const startIndex = (currentPage - 1) * postsPerPage;
            const endIndex = startIndex + postsPerPage;
            const pagePosts = allPosts.slice(startIndex, endIndex);
            
            // Update pagination controls
            const totalPages = Math.ceil(allPosts.length / postsPerPage);
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;
            
            // Render each post
            pagePosts.forEach(post => {
                const postElement = createPostElement(post);
                postsContainer.appendChild(postElement);
            });
            
            // Update displayed count
            displayedPostsElement.textContent = allPosts.length;
        }
        
        // Create post element
        function createPostElement(post) {
            const div = document.createElement('div');
            div.className = 'post-card';
            
            // Format date
            const date = new Date(post.timestamp || post.created_at);
            const formattedDate = date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // Media type icons
            const mediaIcons = {
                text: 'üìù',
                photo: 'üñºÔ∏è',
                video: 'üé¨',
                document: 'üìÑ',
                audio: 'üéµ',
                sticker: 'ü§°'
            };
            
            const mediaIcon = mediaIcons[post.media_type] || 'üìã';
            const categoryClass = `category-${post.category || 'general'}`;
            
            // Truncate content if too long
            const maxLength = 200;
            let contentPreview = post.content || 'No content';
            let isTruncated = contentPreview.length > maxLength;
            
            if (isTruncated) {
                contentPreview = contentPreview.substring(0, maxLength) + '...';
            }
            
            // Create HTML structure
            div.innerHTML = `
                <div class="post-header">
                    <span class="post-id">ID: ${post.message_id || post.id}</span>
                    <span class="post-category ${categoryClass}">${post.category || 'general'}</span>
                </div>
                <div class="post-content">
                    ${escapeHtml(contentPreview)}
                    ${isTruncated ? '<div class="read-more"><button class="read-more-btn" onclick="toggleReadMore(this)">Read More</button></div>' : ''}
                </div>
                <div class="post-footer">
                    <span class="post-media">${mediaIcon} ${post.media_type || 'text'}</span>
                    <span class="post-timestamp">üìÖ ${formattedDate}</span>
                </div>
            `;
            
            // Store full content for read more functionality
            if (isTruncated) {
                div.querySelector('.post-content').dataset.fullContent = post.content;
            }
            
            return div;
        }
        
        // Global function for read more/less toggle
        window.toggleReadMore = function(button) {
            const contentDiv = button.closest('.post-content');
            const readMoreDiv = button.closest('.read-more');
            
            if (contentDiv.classList.contains('expanded')) {
                // Collapse
                contentDiv.classList.remove('expanded');
                const truncated = contentDiv.dataset.fullContent.substring(0, 200) + '...';
                contentDiv.innerHTML = escapeHtml(truncated) + 
                    '<div class="read-more"><button class="read-more-btn" onclick="toggleReadMore(this)">Read More</button></div>';
            } else {
                // Expand
                contentDiv.classList.add('expanded');
                contentDiv.innerHTML = escapeHtml(contentDiv.dataset.fullContent) + 
                    '<div class="read-more"><button class="read-more-btn" onclick="toggleReadMore(this)">Read Less</button></div>';
            }
        };
        
        // Show error message
        function showError(message) {
            postsContainer.innerHTML = `
                <div class="no-posts">
                    <div style="font-size:3rem;margin-bottom:10px;">‚ö†Ô∏è</div>
                    <h3>Error Loading Posts</h3>
                    <p>${message}</p>
                    <button onclick="loadPosts()" style="margin-top:15px;padding:10px 20px;background:var(--primary);color:white;border:none;border-radius:8px;cursor:pointer;">
                        Retry
                    </button>
                </div>
            `;
            noPostsMessage.style.display = 'none';
            pagination.style.display = 'none';
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>